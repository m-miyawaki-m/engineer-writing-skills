{
  "terms": [
    {
      "id": "conclusion-first-1",
      "term": "結論ファースト",
      "type": "term",
      "category": "logical-writing",
      "meaning": "最初に結論を述べ、その後に理由や詳細を展開する文章構成法",
      "example": "【結論】本機能はリリース可能です。【理由】全テストが通過し、レビューも完了しています。",
      "antiPattern": "テストを実行しました。全件通過しました。レビューも終わりました。なので、リリース可能です。",
      "usage": "報告・提案・レビューコメントなど、相手に素早く要点を伝えたい場面",
      "createdAt": "2026-02-18"
    },
    {
      "id": "granularity-adjustment-1",
      "term": "粒度調整",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "情報の詳細度を相手や目的に合わせて適切に調整すること",
      "example": "【マネージャー向け】認証基盤の移行が完了し、全サービスで新方式が稼働中です。【開発者向け】OAuth 2.0 + PKCE への移行が完了。既存の Session Cookie 認証は 3/1 に廃止予定。",
      "antiPattern": "認証の移行が終わりました。（相手に関わらず同一粒度）",
      "usage": "報告先に応じて技術詳細の深さを変える場面",
      "createdAt": "2026-02-18"
    },
    {
      "id": "escalation-1",
      "term": "エスカレーション",
      "type": "term",
      "category": "reporting",
      "meaning": "自分の権限や能力では対応できない問題を上位者に報告・判断を仰ぐこと",
      "example": "【状況】本番DBのレプリケーション遅延が30分を超えています。【影響】読み取り系APIのデータ不整合リスクあり。【判断依頼】サービス一時停止の判断をお願いします。",
      "antiPattern": "DBがなんかおかしいです。どうしましょう？",
      "usage": "障害対応、リソース不足、方針判断が必要な場面",
      "createdAt": "2026-02-18"
    },
    {
      "id": "ambiguity-elimination-1",
      "term": "曖昧さ排除",
      "type": "term",
      "category": "questioning",
      "meaning": "「適切に」「なるべく早く」等の曖昧表現を具体的な条件・数値に置き換えること",
      "example": "「なるべく早く」→「今週金曜 17:00 まで」、「適切に処理」→「バリデーションエラー時は 400 を返し、エラー内容を errors 配列に格納」",
      "antiPattern": "適切にエラーハンドリングしてください。なるべく早くお願いします。",
      "usage": "要件定義、タスク依頼、レビューコメント",
      "createdAt": "2026-02-18"
    },
    {
      "id": "specification-explanation-1",
      "term": "仕様説明の型",
      "type": "term",
      "category": "explanation",
      "meaning": "仕様を【目的→入力→処理→出力→制約】の順で体系的に説明する方法",
      "example": "【目的】ユーザーのセッション管理。【入力】ログインリクエスト（email, password）。【処理】認証後 JWT を発行。【出力】access_token（有効期限15分）+ refresh_token。【制約】同時セッション数は最大5。",
      "antiPattern": "ログインしたら JWT を返します。",
      "usage": "設計レビュー、API仕様説明、新機能の概要説明",
      "createdAt": "2026-02-18"
    },
    {
      "id": "task-decomposition-1",
      "term": "タスク分解",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "大きな作業を実行可能な小さい単位に分割し、依存関係と優先度を明確にすること",
      "example": "【元タスク】ユーザー認証機能の実装\n【分解】\n1. DB: usersテーブル作成（ブロッカーなし）\n2. API: POST /auth/login エンドポイント（1に依存）\n3. API: JWT発行・検証ミドルウェア（2に依存）\n4. Front: ログインフォームUI（ブロッカーなし）\n5. Front: 認証状態管理（3,4に依存）\n6. Test: E2Eテスト（5に依存）",
      "antiPattern": "「認証機能を作る」というタスク1つだけをチケットに登録し、完了まで数日間進捗が見えない",
      "usage": "スプリント計画、チケット作成、作業見積もり、プルリクエストの分割",
      "createdAt": "2026-02-18"
    },
    {
      "id": "todo-checklist-1",
      "term": "TODOチェックリスト作成",
      "type": "term",
      "category": "logical-writing",
      "meaning": "作業の抜け漏れを防ぐため、完了条件が明確な項目を列挙したチェックリストを作成すること",
      "example": "## リリース前チェックリスト\n- [ ] 全テスト通過（unit / integration / E2E）\n- [ ] コードレビュー承認済み（2名以上）\n- [ ] ステージング環境で動作確認完了\n- [ ] マイグレーション手順書作成済み\n- [ ] ロールバック手順書作成済み\n- [ ] 関係者への事前連絡済み",
      "antiPattern": "「リリース準備する」だけを書いて、テスト・レビュー・連絡などの個別項目を明示しない",
      "usage": "リリース準備、コードレビュー依頼、引き継ぎ、定型作業の標準化",
      "createdAt": "2026-02-18"
    },
    {
      "id": "done-definition-1",
      "term": "完了条件の定義（Definition of Done）",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "タスクが「完了」と言える状態を事前に明文化すること。曖昧な「できた」を防ぐ",
      "example": "【完了条件】\n1. 機能が仕様通り動作する（手動確認済み）\n2. ユニットテスト追加済み（カバレッジ80%以上）\n3. APIドキュメント更新済み\n4. レビュー承認済み\n5. ステージングにデプロイ済み",
      "antiPattern": "「実装したら完了」（テスト・ドキュメント・レビューが抜ける）",
      "usage": "チケット作成時、スプリント計画、タスク依頼、Pull Request テンプレート",
      "createdAt": "2026-02-18"
    },
    {
      "id": "research-design-1",
      "term": "調査設計",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "未知の領域を調べる前に、調査の目的・範囲・期限・成果物を定義すること。闇雲に調べ始めるのを防ぐ",
      "example": "【調査目的】プロジェクトへのAI導入の実現可能性を評価する\n【調査範囲】1.自社の課題整理 2.AI技術の選択肢 3.コスト・工数 4.リスク\n【期限】2週間（中間報告: 1週目金曜）\n【成果物】調査報告書 + Go/No-Go判断材料",
      "antiPattern": "「AIについて調べておいて」と言われ、目的も期限も決めず記事を読み漁る",
      "usage": "新技術の導入検討、ツール選定、技術負債の調査、パフォーマンス改善調査",
      "createdAt": "2026-02-18"
    },
    {
      "id": "progressive-goal-refinement-1",
      "term": "段階的ゴール具体化",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "最初は曖昧なゴールを、調査の進行に合わせて段階的に具体化していく手法。最初から完璧なゴールは設定できないと割り切る",
      "example": "【Week0】「AI導入で業務改善したい」（抽象）\n→【Week1 調査後】「問い合わせ対応の一次回答をAIで自動化したい」（具体化）\n→【Week2 PoC後】「FAQ 200件に対し正答率80%以上のチャットボットを3ヶ月で導入する」（定量化）",
      "antiPattern": "最初から「正答率95%のAIを作る」と決めて、実現不可能な目標に時間を費やす",
      "usage": "新規プロジェクト立ち上げ、技術選定、R&D、不確実性の高いタスク",
      "createdAt": "2026-02-18"
    },
    {
      "id": "poc-1",
      "term": "PoC（概念実証）",
      "type": "term",
      "category": "explanation",
      "meaning": "本格実装の前に、技術的に実現可能かを最小限の実装で検証すること",
      "example": "【PoC目的】GPT-4でFAQ自動回答が実用レベルか検証\n【検証項目】1.正答率 2.応答速度 3.コスト/件\n【PoC範囲】FAQ上位50件で検証（全200件の25%）\n【期間】3日間\n【成功基準】正答率70%以上 かつ 応答3秒以内\n【結果】正答率78%、平均応答1.2秒 → 本格導入に進む",
      "antiPattern": "PoCなしでいきなり全機能を作り始め、3ヶ月後に「使えない」と判明する",
      "usage": "新技術導入、外部API連携、アーキテクチャ変更、AI/ML機能の導入",
      "createdAt": "2026-02-18"
    },
    {
      "id": "results-report-1",
      "term": "成果報告書の型",
      "type": "term",
      "category": "reporting",
      "meaning": "調査・実装の成果を【目的→手法→結果→考察→次のアクション】の構造で報告すること",
      "example": "【目的】AI導入による問い合わせ対応コスト削減の検証\n【手法】GPT-4 API + RAG構成でFAQ50件を対象にPoC実施\n【結果】正答率78%、応答1.2秒、コスト0.8円/件（人件費比95%削減）\n【考察】FAQ形式の定型回答は高精度。自由記述の複合質問は正答率40%で要改善\n【次のアクション】Phase2: プロンプト改善＋回答精度の低いカテゴリ特定",
      "antiPattern": "「AIを試しました。なかなかいい感じです。」",
      "usage": "技術調査報告、PoC結果報告、四半期レビュー、プロジェクト完了報告",
      "createdAt": "2026-02-18"
    },
    {
      "id": "knowledge-accumulation-1",
      "term": "ナレッジ蓄積と再利用",
      "type": "term",
      "category": "logical-writing",
      "meaning": "調査・実装で得た知見を、次のプロジェクトや他メンバーが再利用できる形で文書化すること",
      "example": "【知見の分類】\n1. 技術知見: GPT-4のRAG構成ではチャンクサイズ500トークンが最適だった\n2. プロセス知見: PoCは3日以内に区切ると判断が早い\n3. 失敗知見: embedding検索だけでは複合質問に対応できない\n【蓄積先】社内Wiki > AI導入 > FAQ自動応答\n【再利用方法】次回のAI案件では本ドキュメントのPoC設計をテンプレートとして使う",
      "antiPattern": "調査報告書を書いて終わり。次のプロジェクトでまたゼロから調べ直す",
      "usage": "プロジェクト完了時、スプリントレトロスペクティブ、技術ブログ執筆、チーム引き継ぎ",
      "createdAt": "2026-02-18"
    },
    {
      "id": "summary-1",
      "term": "サマリー（要約）",
      "type": "term",
      "category": "reporting",
      "meaning": "情報を圧縮して要点だけを伝える文書。読み手が全体像を素早く把握するためのもの。判断や考察は含まず、事実の整理が主目的",
      "example": "【会議サマリー】\n・議題: 認証基盤の移行方針\n・参加者: 田中、佐藤、鈴木\n・決定事項: OAuth 2.0 + PKCE を採用\n・宿題: 佐藤がマイグレーション手順書を金曜までに作成\n・次回: 2/25 14:00",
      "antiPattern": "会議で色々話しました。認証の話が中心でした。来週また集まります。",
      "usage": "会議議事録、長文ドキュメントの冒頭、メール冒頭の3行まとめ、Slack での共有",
      "createdAt": "2026-02-18"
    },
    {
      "id": "report-types-1",
      "term": "報告の目的別分類",
      "type": "term",
      "category": "reporting",
      "meaning": "報告を目的で分類し、それぞれに適した構成を使い分けること。混同すると「で、何をしてほしいの？」と言われる",
      "example": "1. 情報共有型（サマリー）: 事実を圧縮して伝える → 議事録、日報、週報\n2. 判断依頼型（エスカレーション）: 状況＋選択肢を提示し判断を仰ぐ → 障害報告、方針相談\n3. 成果報告型: 目的→手法→結果→考察→次アクションで報告 → PoC報告、プロジェクト完了報告\n4. 提案型: 課題＋解決策＋根拠＋コストで説得 → 技術選定提案、改善提案",
      "antiPattern": "全ての報告を同じフォーマットで書く。日報に考察を延々と書いたり、成果報告に事実だけ並べたり",
      "usage": "あらゆる報告の書き出し前に「この報告の目的は何か」を確認する",
      "createdAt": "2026-02-18"
    },
    {
      "id": "daily-weekly-monthly-1",
      "term": "日報・週報・月報の使い分け",
      "type": "term",
      "category": "reporting",
      "meaning": "報告の頻度に応じて粒度と目的を変えること。日報は事実の記録、週報は傾向の把握、月報は成果の評価",
      "example": "【日報】今日やったこと・明日やること・困っていること（事実ベース、2〜3分で書ける量）\n【週報】今週の進捗サマリー・来週の計画・リスク/ブロッカー（傾向が見える粒度）\n【月報】目標に対する達成度・成果の数値・学び・来月の方針（評価と振り返り）",
      "antiPattern": "日報に月報レベルの振り返りを書く（重すぎて続かない）。月報に日報レベルの詳細を書く（読み手が読みきれない）",
      "usage": "チーム内の定期報告、1on1の事前準備、自己評価",
      "createdAt": "2026-02-18"
    },
    {
      "id": "executive-summary-1",
      "term": "エグゼクティブサマリー",
      "type": "term",
      "category": "explanation",
      "meaning": "意思決定者向けに、長い報告書の結論と推奨アクションを冒頭1ページにまとめたもの。詳細を読まなくても判断できるようにする",
      "example": "## エグゼクティブサマリー\n【結論】AI FAQ自動応答の導入を推奨します\n【根拠】PoCで正答率78%、コスト95%削減を確認\n【投資】初期100万 + 月額5万（12ヶ月で回収）\n【リスク】複合質問の精度不足 → 段階導入で対応\n【推奨アクション】来月からPhase1（定型FAQ自動化）を開始\n\n※詳細は本文 p.3〜 を参照",
      "antiPattern": "10ページの報告書を渡して「全部読んでください」",
      "usage": "経営層への提案書、プロジェクト完了報告、投資判断資料",
      "createdAt": "2026-02-18"
    },
    {
      "id": "library-investigation-1",
      "term": "ライブラリ調査の型",
      "type": "term",
      "category": "explanation",
      "meaning": "ライブラリやツールの導入・移行を検討する際に、現状→候補→比較軸→比較→推奨の構造で調査を行うこと",
      "example": "【現状】moment.js v2.29（EOL済み、セキュリティパッチ停止）\n【候補】A. date-fns / B. dayjs / C. Temporal API\n【比較軸】バンドルサイズ / API互換性 / 移行コスト / 長期安定性\n【推奨】B. dayjs（moment互換でコスト最小）",
      "antiPattern": "「moment.jsが古いのでdayjsに変えます」（比較なし、根拠なし、影響調査なし）",
      "usage": "技術選定、ライブラリ移行、新規ツール導入検討",
      "createdAt": "2026-02-18"
    },
    {
      "id": "eol-management-1",
      "term": "EOL（End of Life）管理",
      "type": "term",
      "category": "reporting",
      "meaning": "使用中のライブラリ・言語・ツールのサポート終了日を把握し、計画的に移行すること。EOL後はセキュリティパッチが停止するため放置はリスク",
      "example": "【EOL管理台帳】\n| ツール | 現行ver | EOL日 | 目標ver | 移行期限 | 担当 |\n|---|---|---|---|---|---|\n| Node.js | 18.x | 2025/4 | 22.x LTS | 2025/3 | 田中 |\n| Python | 3.9 | 2025/10 | 3.12 | 2025/8 | 佐藤 |\n| React | 17 | - | 19 | 2025/6 | 鈴木 |",
      "antiPattern": "EOLを把握しておらず、ある日突然セキュリティ監査で指摘されて慌てて対応する",
      "usage": "技術負債管理、セキュリティ対応、四半期の技術ロードマップ策定",
      "createdAt": "2026-02-18"
    },
    {
      "id": "language-investigation-1",
      "term": "言語・ランタイム調査",
      "type": "term",
      "category": "explanation",
      "meaning": "プログラミング言語やランタイムの新バージョン・新機能・破壊的変更を調査し、移行判断の材料を整理すること",
      "example": "【調査対象】Python 3.12\n【主な新機能】\n1. PEP 695: 型パラメータ構文の簡略化\n2. PEP 684: サブインタプリタごとのGIL\n3. パフォーマンス改善（5〜10%高速化）\n【破壊的変更】distutils完全削除、一部deprecation関数の除去\n【影響】自社コードで distutils 使用箇所3件 → setuptools に置換必要\n【判断】移行推奨（工数0.5日、リスク低）",
      "antiPattern": "「Python 3.12が出たので上げましょう」（新機能も破壊的変更も影響も調査していない）",
      "usage": "言語バージョンアップ、ランタイム移行、新言語採用の検討",
      "createdAt": "2026-02-18"
    },
    {
      "id": "dependency-audit-1",
      "term": "依存パッケージ監査",
      "type": "term",
      "category": "logical-writing",
      "meaning": "プロジェクトが依存する外部パッケージの脆弱性・非推奨・EOL状況を定期的にチェックし、リスクを管理すること",
      "example": "【監査ツール】npm audit / pip-audit / bundler-audit\n【定期実行】CI/CDパイプラインに組み込み、週次で自動チェック\n【トリアージ基準】\n- Critical/High: 即日対応\n- Medium: 1週間以内\n- Low: 次スプリントで対応\n【レポート例】\n脆弱性: 2件（High1, Low1）\n非推奨: 5件（うちEOL 1件）\n対応状況: High1件は本日中にPR作成済み",
      "antiPattern": "npm audit の警告を無視し続け、数百件溜まってから「何とかしないと」と騒ぐ",
      "usage": "CI/CDパイプライン設計、セキュリティレビュー、定期メンテナンス",
      "createdAt": "2026-02-18"
    },
    {
      "id": "migration-plan-1",
      "term": "移行計画書の型",
      "type": "term",
      "category": "reporting",
      "meaning": "ライブラリ・言語・ツールの移行時に【背景→影響調査→手順→テスト→ロールバック】を一貫して記述する計画書",
      "example": "【背景】Node.js 18がEOL超過、セキュリティパッチ停止\n【影響】非互換パッケージ3件（node-sass, sharp, bcrypt）\n【手順】5ステップ（切替→パッケージ更新→テスト→ステージング→本番）\n【テスト】unit + E2E全件通過を確認\n【ロールバック】Dockerイメージの前バージョンに即時切り戻し\n【見積もり】1人日",
      "antiPattern": "「Node.jsを22に上げます」→ テスト通らず → ロールバック手順もなく本番障害",
      "usage": "バージョンアップ、ライブラリ置換、インフラ移行",
      "createdAt": "2026-02-18"
    },
    {
      "id": "requirements-definition-1",
      "term": "要件定義",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "システムが「何を実現すべきか」を定義する最上流工程。機能要件（何ができるか）と非機能要件（性能・セキュリティ・可用性等）を明文化する。ここがずれると全工程に波及する",
      "example": "【機能要件】\nFR-001: ユーザーはメールアドレスとパスワードでログインできる\nFR-002: ログイン失敗5回で30分間アカウントロック\nFR-003: パスワードリセット機能（メール認証）\n\n【非機能要件】\nNFR-001: ログインAPIの応答時間は95%タイルで500ms以内\nNFR-002: パスワードはbcrypt（コスト12）でハッシュ化\nNFR-003: 同時ログインセッション数は最大5",
      "antiPattern": "「ログイン機能を作ってください」（機能要件も非機能要件も不明。性能要件もセキュリティ要件もない）",
      "usage": "プロジェクト初期のステークホルダーとの合意形成、RFP作成、開発着手前の仕様確定",
      "createdAt": "2026-02-18"
    },
    {
      "id": "basic-design-1",
      "term": "基本設計（外部設計）",
      "type": "term",
      "category": "explanation",
      "meaning": "システム全体のアーキテクチャ、外部インターフェース、データベース構成を定義する工程。要件定義の「何を」を「どの構成で実現するか」に変換する。結合テストの検証基準になる",
      "example": "【システム構成】3層アーキテクチャ（フロント/API/DB）\n【外部IF】REST API 15エンドポイント、外部認証連携（OAuth2.0）\n【DB設計】ER図（テーブル12、主要リレーション8）\n【画面遷移】画面一覧20画面、遷移図\n【非機能設計】CDN + ロードバランサ + DBレプリケーション",
      "antiPattern": "要件定義書をそのまま設計書と称して、アーキテクチャも技術選定も記載しない",
      "usage": "設計レビュー、顧客承認、結合テスト計画のインプット",
      "createdAt": "2026-02-18"
    },
    {
      "id": "overview-design-1",
      "term": "概要設計（機能設計）",
      "type": "term",
      "category": "explanation",
      "meaning": "基本設計で定義した構成を機能単位に分解し、各機能の入出力・処理フロー・画面レイアウトを定義する工程。詳細テスト（機能テスト）の検証基準になる",
      "example": "【機能】ログイン機能\n【画面】ログインフォーム（メール入力欄、パスワード入力欄、ログインボタン）\n【処理フロー】\n1. 入力バリデーション（メール形式、パスワード8文字以上）\n2. DB照合（usersテーブル）\n3. ロック判定（login_attemptsテーブル）\n4. JWT発行（access_token + refresh_token）\n5. レスポンス返却（200 + tokens / 401 + エラー詳細）\n【エラー処理】認証失敗→失敗回数インクリメント、5回→ロック",
      "antiPattern": "「ログイン画面を作る」だけで、処理フロー・バリデーション・エラー処理の定義がない",
      "usage": "開発者への仕様伝達、機能テスト設計のインプット、画面モック作成",
      "createdAt": "2026-02-18"
    },
    {
      "id": "detailed-design-1",
      "term": "詳細設計（内部設計）",
      "type": "term",
      "category": "explanation",
      "meaning": "概要設計の処理フローをクラス・関数・アルゴリズムレベルに落とし込む工程。単体テストの検証基準になる。実装者が迷わずコードを書ける粒度にする",
      "example": "【クラス】AuthService\n【メソッド】authenticate(email, password) -> TokenPair\n【処理詳細】\n1. User.findByEmail(email) → null時 AuthenticationError\n2. bcrypt.compare(password, user.hashedPassword) → false時 AuthenticationError\n3. LoginAttempt.countRecent(user.id, 30min) → >=5 時 AccountLockedError\n4. TokenService.generate(user) → {accessToken(15min), refreshToken(30日)}\n5. LoginAttempt.reset(user.id)\n【境界条件】email=null, password=空文字, user削除済み, token生成失敗",
      "antiPattern": "「認証処理を実装する」だけで、メソッド名・引数・戻り値・例外の定義がない",
      "usage": "実装のインプット、単体テスト設計の基準、コードレビューの照合元",
      "createdAt": "2026-02-18"
    },
    {
      "id": "v-model-1",
      "term": "V字モデル（工程対応）",
      "type": "term",
      "category": "logical-writing",
      "meaning": "開発工程（左）とテスト工程（右）が対応するモデル。各設計工程の成果物が、対応するテスト工程の検証基準になる。この対応関係がずれると「何をテストすべきか」が曖昧になる",
      "example": "【V字モデルの対応関係】\n要件定義 ←――→ システムテスト（受入テスト）\n  基本設計 ←――→ 結合テスト\n    概要設計 ←――→ 詳細テスト（機能テスト）\n      詳細設計 ←――→ 単体テスト\n        実装\n\n【対応の意味】\n・詳細設計で定義した条件分岐 → 単体テストで全分岐を検証\n・概要設計で定義した処理フロー → 機能テストで正常系/異常系を検証\n・基本設計で定義したIF仕様 → 結合テストでモジュール間連携を検証\n・要件定義の機能要件 → システムテストで業務シナリオを検証",
      "antiPattern": "設計書とテスト仕様書が独立して作られ、設計変更がテストに反映されない。テストで何を確認しているかの根拠が不明",
      "usage": "テスト計画策定、品質保証、プロジェクト全体の工程管理",
      "createdAt": "2026-02-18"
    },
    {
      "id": "traceability-1",
      "term": "トレーサビリティ（追跡可能性）",
      "type": "term",
      "category": "logical-writing",
      "meaning": "要件→設計→実装→テストの各成果物が一貫して紐付いていること。「この要件はどの設計に落ちているか」「このテストはどの要件を検証しているか」を追跡できる状態",
      "example": "【トレーサビリティマトリクス】\n| 要件ID | 基本設計 | 概要設計 | 詳細設計 | 実装 | UT | FT | IT |\n|---|---|---|---|---|---|---|---|\n| FR-001 | BD-3.1 | OD-3.1.1 | DD-Auth-01 | AuthService | UT-A01〜05 | FT-L01〜08 | IT-Auth-01〜03 |\n| FR-002 | BD-3.2 | OD-3.1.2 | DD-Auth-02 | LockService | UT-L01〜04 | FT-L09〜12 | IT-Auth-04 |\n| NFR-001 | BD-4.1 | - | DD-Perf-01 | - | - | - | PT-001 |",
      "antiPattern": "要件一覧、設計書、テスト仕様書がバラバラに存在し、要件変更時にどのテストを修正すべきかわからない",
      "usage": "品質管理、要件変更時の影響分析、テストカバレッジの確認、監査対応",
      "createdAt": "2026-02-18"
    },
    {
      "id": "unit-test-design-1",
      "term": "単体テスト（UT）",
      "type": "term",
      "category": "logical-writing",
      "meaning": "詳細設計で定義したクラス・関数単位の動作を検証するテスト。条件分岐・境界値・異常系を網羅する。検証基準は詳細設計書",
      "example": "【対応する詳細設計】DD-Auth-01: AuthService.authenticate()\n【テスト観点】\nUT-A01: 正常系 - 正しいemail/passwordでTokenPairが返る\nUT-A02: 異常系 - 存在しないemailでAuthenticationError\nUT-A03: 異常系 - パスワード不一致でAuthenticationError\nUT-A04: 境界値 - ロック回数4回（ロックされない）\nUT-A05: 境界値 - ロック回数5回（AccountLockedError）\nUT-A06: 異常系 - email=null でバリデーションエラー\nUT-A07: 異常系 - 削除済みユーザーでAuthenticationError",
      "antiPattern": "「ログインできることを確認」だけで、境界値・異常系・エラーケースのテストがない",
      "usage": "実装完了後の品質確認、CI/CDパイプライン、リグレッション防止",
      "createdAt": "2026-02-18"
    },
    {
      "id": "functional-test-1",
      "term": "詳細テスト（機能テスト / FT）",
      "type": "term",
      "category": "logical-writing",
      "meaning": "概要設計で定義した機能単位の処理フローを検証するテスト。画面操作→処理→結果の一連の流れを確認する。検証基準は概要設計書",
      "example": "【対応する概要設計】OD-3.1.1: ログイン機能\n【テスト観点】\nFT-L01: 正常ログイン → トップ画面に遷移\nFT-L02: メール形式不正 → バリデーションエラー表示\nFT-L03: パスワード7文字 → バリデーションエラー表示\nFT-L04: 未登録メール → 「認証に失敗しました」表示\nFT-L05: パスワード誤り → 「認証に失敗しました」表示\nFT-L06: 5回失敗後 → 「アカウントがロックされています」表示\nFT-L07: ロック中にログイン試行 → ロックメッセージ維持\nFT-L08: 30分経過後 → ロック解除されログイン可能",
      "antiPattern": "「ログインできること」「ログインできないこと」の2ケースだけ。概要設計で定義したエラーパターンやロック仕様のテストが欠落",
      "usage": "機能実装完了後の検証、QAチームへの引き渡し、受入テスト準備",
      "createdAt": "2026-02-18"
    },
    {
      "id": "integration-test-1",
      "term": "結合テスト（IT）",
      "type": "term",
      "category": "logical-writing",
      "meaning": "基本設計で定義したモジュール間・システム間のインターフェースを検証するテスト。API連携・DB連携・外部サービス連携が仕様通りか確認する。検証基準は基本設計書",
      "example": "【対応する基本設計】BD-3.1: 認証モジュール ↔ ユーザー管理モジュール\n【テスト観点】\nIT-Auth-01: フロント → 認証API → DB の一気通貫ログインフロー\nIT-Auth-02: 認証API → トークン検証ミドルウェア → 保護APIへのアクセス制御\nIT-Auth-03: 認証API → メールサービス連携（パスワードリセット）\nIT-Auth-04: 認証API → 外部OAuth（Google/GitHub）連携\n【確認ポイント】\n・IF仕様（リクエスト/レスポンスの形式）が基本設計通りか\n・エラー時のモジュール間の伝播が想定通りか\n・トランザクション境界が正しいか",
      "antiPattern": "各モジュール単体ではテスト済みだが、繋ぎ合わせたときのIF不整合やデータ不整合を検証していない",
      "usage": "モジュール結合時の品質確認、外部連携の検証、本番環境リリース前の最終確認",
      "createdAt": "2026-02-18"
    },
    {
      "id": "test-perspective-alignment-1",
      "term": "テスト観点の整合性",
      "type": "term",
      "category": "questioning",
      "meaning": "各テスト工程の観点が対応する設計工程と一致していること。設計で定義した内容がテストで漏れなく検証され、設計にない観点がテストに混入していないことを確認する",
      "example": "【整合性チェック】\n✅ 詳細設計の条件分岐5パターン → 単体テスト5ケース（対応OK）\n✅ 概要設計のエラー処理4種類 → 機能テスト4ケース（対応OK）\n❌ 基本設計のAPI 15本 → 結合テスト12本（3本テスト漏れ）\n❌ 要件FR-003 → どのテストにも紐付かない（トレーサビリティ欠落）\n\n【よくあるずれ】\n1. 設計変更がテストに未反映（設計は修正したがテストは旧仕様のまま）\n2. テスト観点が設計と異なるレベル（単体テストで結合テスト相当を実施）\n3. 非機能要件のテスト漏れ（性能・セキュリティが未検証）",
      "antiPattern": "設計書を見ずにテストを書く。テスト仕様書と設計書の対応関係が不明。設計変更時にテストを更新しない",
      "usage": "テストレビュー、品質管理、工程完了判定、設計変更時の影響分析",
      "createdAt": "2026-02-18"
    }
  ],
  "patterns": [
    {
      "id": "mece-decomposition-1",
      "term": "MECE分解",
      "type": "pattern",
      "category": "concretization-abstraction",
      "meaning": "漏れなくダブりなく要素を分解する思考法",
      "goodExample": "障害原因を【ネットワーク層】【アプリケーション層】【データベース層】【インフラ層】に分類して調査",
      "badExample": "障害原因を【サーバー】【ネットワーク】【システム】に分類（サーバーとシステムの境界が曖昧で重複あり）",
      "usage": "要件分解、障害分析、タスク分割、テスト観点の洗い出し",
      "createdAt": "2026-02-18"
    },
    {
      "id": "progress-report-template-1",
      "term": "進捗報告テンプレート",
      "type": "pattern",
      "category": "reporting",
      "meaning": "【完了/進行中/未着手/ブロッカー】の4区分で進捗を構造化する報告パターン",
      "goodExample": "【完了】API設計・実装（3/3タスク）\n【進行中】フロント実装（2/5タスク、今日中に3/5予定）\n【未着手】E2Eテスト\n【ブロッカー】ステージング環境の権限待ち（インフラチームに依頼済み）",
      "badExample": "APIは終わりました。フロントをやっています。テストはまだです。あと環境の件があります。",
      "usage": "デイリースタンドアップ、週次報告、プロジェクト状況共有",
      "createdAt": "2026-02-18"
    },
    {
      "id": "review-comment-pattern-1",
      "term": "レビューコメントの型",
      "type": "pattern",
      "category": "explanation",
      "meaning": "【指摘レベル＋理由＋改善案】を明示するコードレビューコメントの書き方",
      "goodExample": "[must] N+1クエリが発生しています。ユーザー100件でクエリが101回実行されます。`includes(:posts)` を追加して eager loading にしてください。",
      "badExample": "ここ、パフォーマンス悪そうです。",
      "usage": "コードレビュー、設計レビュー、ドキュメントレビュー",
      "createdAt": "2026-02-18"
    },
    {
      "id": "causal-chain-1",
      "term": "因果関係の連鎖",
      "type": "pattern",
      "category": "logical-writing",
      "meaning": "原因→結果を明示的に繋いで論理の飛躍を防ぐ文章構成パターン",
      "goodExample": "メモリリークが発生（原因）→ GC頻度が増加（結果1/原因2）→ レスポンスタイムが悪化（結果2/原因3）→ タイムアウトエラーが多発（最終結果）",
      "badExample": "メモリリークがあったのでタイムアウトが多発しました。（中間の因果が省略されていて論理が飛躍）",
      "usage": "障害報告の原因分析、技術選定の根拠説明",
      "createdAt": "2026-02-18"
    },
    {
      "id": "summary-vs-report-pattern-1",
      "term": "サマリーと成果報告の構成比較",
      "type": "pattern",
      "category": "reporting",
      "meaning": "サマリーは「事実の圧縮」、成果報告は「事実＋解釈＋次のアクション」。目的に応じて構成を切り替える",
      "goodExample": "【サマリー（情報共有が目的）】\n・AI FAQ PoCを実施\n・対象: FAQ50件、期間3日\n・結果: 正答率78%、応答1.2秒\n・次回会議で方針決定予定\n\n【成果報告（判断・評価が目的）】\n## 目的\nAI導入のコスト削減効果の検証\n## 手法\nGPT-4 + RAG構成でFAQ50件を対象にPoC\n## 結果\n正答率78%（定型92%/複合40%）、コスト0.8円/件\n## 考察\n定型FAQは即導入可能。複合質問は段階的改善が必要\n## 推奨アクション\nPhase1として定型FAQ自動化を来月開始",
      "badExample": "サマリーに考察や提案を長々書く（読み手は事実だけ欲しい）。成果報告に事実だけ並べて「で、どうすればいいの？」と言われる",
      "usage": "Slack/メールでのサマリー、正式な成果報告書、会議での口頭報告",
      "createdAt": "2026-02-18"
    },
    {
      "id": "report-audience-pattern-1",
      "term": "読み手別の報告構成パターン",
      "type": "pattern",
      "category": "explanation",
      "meaning": "同じ内容でも読み手によって構成・粒度・強調ポイントを変えるパターン",
      "goodExample": "【経営層向け】\n結論→ビジネスインパクト→コスト→リスク→推奨アクション\n（技術詳細は省略、数字で語る）\n\n【技術リーダー向け】\n結論→技術選定理由→アーキテクチャ→性能検証結果→技術的リスク\n（実装の詳細を含む）\n\n【チームメンバー向け】\n概要→タスク分解→各自の担当→スケジュール→質問\n（行動に直結する情報を中心に）",
      "badExample": "経営層にアーキテクチャ図を30分説明する。チームメンバーにビジネスインパクトの数字だけ見せる",
      "usage": "プレゼン準備、報告書作成、メールの宛先ごとの書き分け",
      "createdAt": "2026-02-18"
    },
    {
      "id": "question-template-1",
      "term": "質問の型",
      "type": "pattern",
      "category": "questioning",
      "meaning": "【前提共有＋自分の理解＋具体的な質問】で構成する質問パターン",
      "goodExample": "【前提】認証APIの仕様書 v2.1 を読みました。【自分の理解】refresh_token の有効期限は30日で、期限切れ時は再ログインが必要と理解しています。【質問】refresh_token を自動延長する仕組みは意図的に入れていないのでしょうか？セキュリティ要件との兼ね合いを確認したいです。",
      "badExample": "refresh_token の仕様がよくわかりません。教えてください。",
      "usage": "仕様確認、技術的な疑問の解消、レビューでの確認",
      "createdAt": "2026-02-18"
    },
    {
      "id": "task-decomposition-pattern-1",
      "term": "タスク分解テンプレート",
      "type": "pattern",
      "category": "concretization-abstraction",
      "meaning": "【目的→前提→分解→依存関係→見積もり】の順でタスクを構造化する分解パターン",
      "goodExample": "【目的】検索機能の実装\n【前提】Elasticsearch導入済み、APIフレームワークはFastAPI\n【分解】\n  1. インデックス定義・マッピング作成（0.5h）\n  2. 検索APIエンドポイント実装（2h）→ 1に依存\n  3. フィルタ・ソート・ページネーション（1.5h）→ 2に依存\n  4. フロント検索UI（2h）→ ブロッカーなし\n  5. 結合テスト（1h）→ 3,4に依存\n【合計見積もり】7h（バッファ込み8h）",
      "badExample": "検索機能を作る。たぶん2〜3日くらい。",
      "usage": "スプリント計画、見積もり依頼への回答、技術調査報告",
      "createdAt": "2026-02-18"
    },
    {
      "id": "checklist-pattern-1",
      "term": "チェックリスト設計パターン",
      "type": "pattern",
      "category": "logical-writing",
      "meaning": "【カテゴリ分類＋完了条件明示＋担当/期限】で構成する実用的チェックリスト",
      "goodExample": "## PR マージ前チェックリスト\n\n### コード品質\n- [ ] Lintエラーなし\n- [ ] 型エラーなし（tsc --noEmit 通過）\n- [ ] 不要なconsole.log削除済み\n\n### テスト\n- [ ] 新規テスト追加済み\n- [ ] 既存テスト全件通過\n- [ ] エッジケース確認済み（null, 空配列, 境界値）\n\n### ドキュメント\n- [ ] API仕様書更新済み（該当する場合）\n- [ ] CHANGELOG追記済み",
      "badExample": "- [ ] コード書いた\n- [ ] テストした\n- [ ] 確認した",
      "usage": "PRテンプレート、リリースチェック、新メンバーオンボーディング、障害対応手順",
      "createdAt": "2026-02-18"
    },
    {
      "id": "wbs-pattern-1",
      "term": "WBS（作業分解構成図）",
      "type": "pattern",
      "category": "concretization-abstraction",
      "meaning": "成果物ベースで作業をツリー構造に分解し、末端をアクション可能な粒度にするパターン",
      "goodExample": "認証機能\n├── バックエンド\n│   ├── DB設計（usersテーブル、sessionsテーブル）\n│   ├── 認証API（login, logout, refresh）\n│   └── ミドルウェア（JWT検証、レート制限）\n├── フロントエンド\n│   ├── ログイン画面\n│   ├── 認証状態管理（store）\n│   └── 認証ガード（ルーティング）\n└── テスト・運用\n    ├── 単体テスト\n    ├── E2Eテスト\n    └── 監視アラート設定",
      "badExample": "認証機能\n├── 設計\n├── 実装\n├── テスト\n（各項目が大きすぎてアクション不可能）",
      "usage": "プロジェクト計画、大規模機能の設計、工数見積もりの根拠",
      "createdAt": "2026-02-18"
    },
    {
      "id": "unknown-domain-research-1",
      "term": "未知領域の調査フレームワーク",
      "type": "pattern",
      "category": "concretization-abstraction",
      "meaning": "何も知らない分野を調査する際に【現状把握→選択肢洗い出し→評価軸設定→比較→推奨案】の順で進めるフレームワーク",
      "goodExample": "Phase1: 現状把握（1日）\n  - 自社の課題を関係者ヒアリングで整理\n  - 「問い合わせ月500件、1件平均15分、人件費月50万」\nPhase2: 選択肢洗い出し（2日）\n  - A. ChatGPT API + RAG\n  - B. 社内FAQ検索エンジン強化\n  - C. チャットボットSaaS導入\nPhase3: 評価軸と比較（1日）\n  | 軸 | A | B | C |\n  |---|---|---|---|\n  | 初期コスト | 中 | 低 | 高 |\n  | 精度 | 高 | 中 | 中 |\n  | 運用負荷 | 中 | 低 | 低 |\nPhase4: 推奨案（0.5日）\n  「Aを推奨。理由: 精度が最重要。PoCで検証後に判断」",
      "badExample": "「AIがいいらしいので ChatGPT を使いましょう」（選択肢の比較なし、評価軸なし）",
      "usage": "新技術導入、ツール選定、アーキテクチャ刷新、業務改善提案",
      "createdAt": "2026-02-18"
    },
    {
      "id": "investigation-to-execution-1",
      "term": "調査→実行→報告の一気通貫テンプレート",
      "type": "pattern",
      "category": "reporting",
      "meaning": "未知の課題に対して【調査設計→調査実行→PoC→本実装計画→成果報告→振り返り】の全工程を一貫して管理するテンプレート",
      "goodExample": "Week1: 調査設計・現状把握\n  - 目的・スコープ・期限を合意\n  - 関係者ヒアリング、現状の定量化\nWeek2: 選択肢調査・比較\n  - 候補技術の洗い出し\n  - 評価軸設定・比較表作成\n  - 【中間報告】選択肢と推奨案を報告\nWeek3: PoC実施\n  - 最小構成で技術検証\n  - 成功基準に対する結果測定\nWeek4: 報告・計画\n  - 【最終報告】結果 + Go/No-Go判断材料\n  - Go の場合: 本実装のWBS・スケジュール案\n  - ナレッジ文書化・Wiki登録",
      "badExample": "「2ヶ月くらい調べます」→ 途中経過なし → 「やっぱり難しそうでした」",
      "usage": "技術導入プロジェクト、R&D、業務改善施策、新規サービス検討",
      "createdAt": "2026-02-18"
    },
    {
      "id": "schedule-with-milestones-1",
      "term": "マイルストーン付きスケジュール",
      "type": "pattern",
      "category": "reporting",
      "meaning": "期間を区切り、各区間の成果物（マイルストーン）を明示するスケジュール。中間判断ポイントを設けてリスクを管理する",
      "goodExample": "【AI FAQ自動応答 導入スケジュール】\nM1 (Week2末): 調査完了 → 技術選定レビュー（Go/No-Go判断①）\nM2 (Week3末): PoC完了 → 精度レポート提出（Go/No-Go判断②）\nM3 (Week6末): MVP完成 → 社内テスト開始\nM4 (Week8末): 本番リリース → 効果測定開始\nM5 (Week12末): 効果レポート → 次フェーズ判断\n\n※ 各マイルストーンで No-Go の場合は撤退基準あり",
      "badExample": "「3ヶ月後にリリース予定です」（中間成果物なし、判断ポイントなし）",
      "usage": "プロジェクト計画書、上長への提案、四半期計画、OKR設定",
      "createdAt": "2026-02-18"
    },
    {
      "id": "retrospective-to-next-action-1",
      "term": "振り返り→次アクション変換",
      "type": "pattern",
      "category": "logical-writing",
      "meaning": "成果報告の振り返りを【事実→解釈→次のアクション】の3段階で変換し、学びを具体的な行動に落とし込むパターン",
      "goodExample": "【事実】FAQ自動応答の正答率は78%だった\n【解釈】定型FAQ（正答率92%）は実用レベル。複合質問（正答率40%）が課題\n【次のアクション】\n1. 複合質問のパターン分類（来週中）\n2. プロンプト改善で正答率60%目標（再来週PoC）\n3. 正答率60%未満のカテゴリは人間にエスカレーションするフロー設計\n\n【横展開】\n- 本PoCの設計テンプレートをWikiに登録（他チーム再利用可）\n- 「PoCは3日以内」ルールを調査ガイドラインに追加",
      "badExample": "【振り返り】うまくいったと思います。次も頑張ります。",
      "usage": "スプリントレトロスペクティブ、プロジェクト完了報告、個人振り返り、1on1",
      "createdAt": "2026-02-18"
    },
    {
      "id": "library-comparison-pattern-1",
      "term": "ライブラリ比較テンプレート",
      "type": "pattern",
      "category": "explanation",
      "meaning": "ライブラリ選定時に【現状の課題→候補一覧→評価軸→比較表→推奨案＋フォールバック】で構造化する",
      "goodExample": "【課題】moment.js EOL済み、セキュリティリスクあり\n【候補】A. date-fns / B. dayjs / C. Temporal\n【評価軸と比較】\n| 軸 | A | B | C |\n|---|---|---|---|\n| サイズ | 12KB | 2KB | 0KB |\n| 互換性 | 低 | 高 | 低 |\n| 移行コスト | 高 | 低 | 高 |\n【推奨】B. dayjs（互換性高・コスト最小）\n【フォールバック】問題時はAに切り替え",
      "badExample": "「dayjs がいいらしいので使いましょう」（比較なし、選定理由なし）",
      "usage": "技術選定ミーティング、ADR（Architecture Decision Record）、移行提案",
      "createdAt": "2026-02-18"
    },
    {
      "id": "eol-management-pattern-1",
      "term": "EOL管理台帳パターン",
      "type": "pattern",
      "category": "reporting",
      "meaning": "使用中の言語・ライブラリ・ツールのEOLを一覧管理し、移行の優先度と期限を可視化するパターン",
      "goodExample": "## 技術スタック EOL管理台帳（2026Q1更新）\n\n### 緊急対応（EOL超過）\n| ツール | 現行ver | EOL | 目標ver | 対応期限 |\n|---|---|---|---|---|\n| Node.js | 18 | 2025/4 ⚠️ | 22 LTS | 今月中 |\n\n### 計画対応（6ヶ月以内にEOL）\n| ツール | 現行ver | EOL | 目標ver | 対応期限 |\n|---|---|---|---|---|\n| Python | 3.9 | 2025/10 | 3.12 | 2025/8 |\n| React | 18 | - | 19 | 2025/6 |\n\n### 安定（1年以上猶予）\n| ツール | 現行ver | EOL | 備考 |\n|---|---|---|---|\n| PostgreSQL | 16 | 2028/11 | 問題なし |",
      "badExample": "EOL管理をしていない。セキュリティ監査で指摘されてから慌てて調べ始める",
      "usage": "四半期の技術ロードマップ、セキュリティ監査準備、技術負債の可視化",
      "createdAt": "2026-02-18"
    },
    {
      "id": "version-upgrade-pattern-1",
      "term": "バージョンアップ影響調査パターン",
      "type": "pattern",
      "category": "explanation",
      "meaning": "言語・ランタイム・ライブラリのバージョンアップ前に【新機能→破壊的変更→依存パッケージ互換性→移行手順→ロールバック】を体系的に調査する",
      "goodExample": "## Node.js 18→22 影響調査\n\n### 新機能（活用候補）\n- Fetch API標準化（node-fetch不要に）\n- テストランナー標準搭載\n\n### 破壊的変更\n- OpenSSL 3.x デフォルト化\n- url.parse() 非推奨化\n\n### 依存パッケージ互換性\n全187パッケージ調査:\n- 互換: 184件\n- 非互換: 3件（node-sass, sharp v0.30, bcrypt v5.0）\n- 各修正方針と工数を記載\n\n### 移行手順（5ステップ）\n1. ブランチ作成 + 切替\n2. 非互換パッケージ修正\n3. テスト実行\n4. ステージング確認\n5. 本番デプロイ\n\n### ロールバック\nDocker前バージョンに即時切り戻し可能",
      "badExample": "「Node.js 22に上げてみたけどエラーが出ました。戻します」（事前調査なし）",
      "usage": "言語バージョンアップ、フレームワーク移行、ランタイム更新",
      "createdAt": "2026-02-18"
    },
    {
      "id": "v-model-mapping-pattern-1",
      "term": "V字モデル工程対応パターン",
      "type": "pattern",
      "category": "logical-writing",
      "meaning": "開発の左工程（設計）と右工程（テスト）の対応関係を明示し、各テストが「何の設計を検証しているか」を定義するパターン",
      "goodExample": "【V字モデル対応表】\n| 設計工程 | 成果物 | 対応テスト | テストで検証すること |\n|---|---|---|---|\n| 要件定義 | 要件一覧 | システムテスト | 業務シナリオ通りに動作するか |\n| 基本設計 | アーキテクチャ・IF仕様 | 結合テスト | モジュール間連携が仕様通りか |\n| 概要設計 | 機能仕様・処理フロー | 機能テスト | 各機能が正常系/異常系で期待通りか |\n| 詳細設計 | クラス・関数仕様 | 単体テスト | 条件分岐・境界値・例外が正しいか |\n\n【ずれの検知方法】\n1. 設計書の項目数とテストケース数の対応を確認\n2. 設計変更履歴とテスト変更履歴を突合\n3. トレーサビリティマトリクスで未対応を検出",
      "badExample": "設計書とテスト仕様書が独立して存在し、対応関係が不明。テストの根拠が「経験上これをテストすべき」のみ",
      "usage": "テスト計画書作成、品質保証プロセス設計、プロジェクト標準策定",
      "createdAt": "2026-02-18"
    },
    {
      "id": "traceability-matrix-pattern-1",
      "term": "トレーサビリティマトリクス",
      "type": "pattern",
      "category": "logical-writing",
      "meaning": "要件→設計→実装→テストの追跡関係を行列で可視化し、漏れ・重複・未対応を検出するパターン",
      "goodExample": "## 認証機能 トレーサビリティマトリクス\n\n| 要件 | 基本設計 | 概要設計 | 詳細設計 | UT | FT | IT |\n|---|---|---|---|---|---|---|\n| FR-001 ログイン | BD-3.1 | OD-3.1.1 | DD-Auth-01 | UT-A01〜07 | FT-L01〜08 | IT-Auth-01 |\n| FR-002 アカウントロック | BD-3.2 | OD-3.1.2 | DD-Auth-02 | UT-L01〜04 | FT-L06〜08 | IT-Auth-02 |\n| FR-003 パスワードリセット | BD-3.3 | OD-3.1.3 | DD-Auth-03 | UT-R01〜05 | FT-R01〜06 | IT-Auth-03 |\n| NFR-001 応答500ms | BD-4.1 | - | DD-Perf-01 | - | - | PT-001 |\n\n【チェック】\n✅ 全要件に対応するテストが存在する\n✅ テストのない設計項目がない\n⚠️ NFR-002（暗号化）のテストが未定義 → 追加必要",
      "badExample": "要件一覧とテスト一覧は別々のExcelファイルで管理。要件変更時にテスト側の更新が漏れる",
      "usage": "品質管理、要件変更の影響分析、監査対応、テストカバレッジ確認",
      "createdAt": "2026-02-18"
    },
    {
      "id": "phase-transition-review-pattern-1",
      "term": "工程移行レビューパターン",
      "type": "pattern",
      "category": "concretization-abstraction",
      "meaning": "次工程に進む前に、前工程の成果物が完成しており次工程のインプットとして十分かを確認するレビューパターン",
      "goodExample": "## 工程移行チェックリスト\n\n### 要件定義 → 基本設計\n- [ ] 全機能要件にIDが振られている\n- [ ] 非機能要件（性能/セキュリティ/可用性）が定義済み\n- [ ] ステークホルダーの承認が得られている\n- [ ] 要件の優先度（Must/Should/Could）が決まっている\n\n### 基本設計 → 概要設計\n- [ ] アーキテクチャ図が作成されている\n- [ ] 外部IF仕様（API一覧・形式）が定義済み\n- [ ] DB設計（ER図）が完成している\n- [ ] 全要件が基本設計のどこかに対応づいている\n\n### 概要設計 → 詳細設計\n- [ ] 全機能の処理フローが定義されている\n- [ ] 画面レイアウトが確定している\n- [ ] エラー処理方針が統一されている\n- [ ] 機能テスト観点が洗い出されている\n\n### 詳細設計 → 実装\n- [ ] クラス/関数の入出力が定義されている\n- [ ] 境界条件・例外処理が明記されている\n- [ ] 単体テスト観点が洗い出されている\n- [ ] コーディング規約が周知されている",
      "badExample": "「だいたい設計できたので実装に入ります」（レビューなし、成果物の完成度が曖昧）",
      "usage": "プロジェクトマネジメント、品質ゲート、ウォーターフォール/ハイブリッド開発",
      "createdAt": "2026-02-18"
    },
    {
      "id": "design-test-alignment-pattern-1",
      "term": "設計−テスト観点整合パターン",
      "type": "pattern",
      "category": "questioning",
      "meaning": "設計書の記載内容からテスト観点を漏れなく導出し、各テストレベル（UT/FT/IT）で何を検証すべきかを明確にするパターン",
      "goodExample": "## 設計→テスト観点の導出ルール\n\n### 詳細設計 → 単体テスト観点\n- 条件分岐 → 全分岐の真偽をテスト\n- 境界値 → 境界値±1をテスト\n- 例外処理 → 全例外パスをテスト\n- 戻り値 → 全パターンの戻り値を検証\n\n### 概要設計 → 機能テスト観点\n- 正常系フロー → 入力→処理→期待出力\n- 異常系フロー → 各エラーパターン\n- 画面遷移 → 遷移図の全パス\n- バリデーション → 入力制約の全条件\n\n### 基本設計 → 結合テスト観点\n- API連携 → リクエスト/レスポンス形式\n- DB連携 → CRUD操作の整合性\n- 外部連携 → 認証・通信エラー・タイムアウト\n- トランザクション → コミット/ロールバック\n\n【ずれの防止策】\n1. テスト設計時に必ず対応する設計書を参照する\n2. 設計変更時に影響テストを特定して更新する\n3. レビューで「このテストの根拠は設計書のどこか」を確認する",
      "badExample": "テスト担当者が設計書を読まずに「思いつく限りのテスト」を書く。設計変更がテストに反映されない",
      "usage": "テスト設計レビュー、テスト計画書作成、品質管理プロセス",
      "createdAt": "2026-02-18"
    },
    {
      "id": "prompt-design-pattern-1",
      "term": "プロンプト設計テンプレート",
      "type": "pattern",
      "category": "explanation",
      "meaning": "AIに対する指示を【役割→文脈→要件→制約→出力形式】で構造化し、意図した回答を得やすくするパターン",
      "goodExample": "## プロンプト設計テンプレート\n\n### 役割（Role）\nあなたは○○の専門家です\n\n### 文脈（Context）\n- 使用技術: TypeScript + Express.js\n- 既存コード: [関連部分を貼付]\n- 状況: ○○の機能を追加したい\n\n### 要件（Requirements）\n1. △△ができること\n2. □□に対応すること\n3. エラー処理を含むこと\n\n### 制約（Constraints）\n- 外部ライブラリは使わない\n- 既存のコード規約に従う\n- テストも含む\n\n### 出力形式（Format）\n- TypeScriptコードブロック\n- 各関数にJSDocコメント\n- 使用例を含む",
      "badExample": "「認証作って」「バグ直して」（役割なし、文脈なし、出力形式なし）",
      "usage": "AIコーディング支援、ドキュメント生成、技術調査、学習",
      "createdAt": "2026-02-18"
    },
    {
      "id": "ai-tool-comparison-pattern-1",
      "term": "AIコーディング支援ツール比較パターン",
      "type": "pattern",
      "category": "explanation",
      "meaning": "チームにAIコーディング支援を導入する際に、ツールの特性を比較し、用途に応じて使い分けるパターン",
      "goodExample": "## AIコーディング支援ツール比較\n\n| 観点 | Copilot | Continue | Cursor | Cline |\n|---|---|---|---|---|\n| 形態 | VSCode拡張 | VSCode拡張(OSS) | 専用エディタ | VSCode拡張 |\n| モデル | GPT-4 | 複数対応 | GPT-4/Claude | 複数対応 |\n| 補完 | インライン | インライン+チャット | インライン+チャット | チャット+自律 |\n| コスト | $19/月 | 無料(API課金) | $20/月 | 無料(API課金) |\n| カスタマイズ | 低 | 高 | 中 | 高 |\n| コードベース理解 | ファイル単位 | 設定次第 | プロジェクト全体 | プロジェクト全体 |\n\n### 用途別推奨\n- 補完メイン → Copilot\n- カスタマイズ・ローカルLLM → Continue\n- AI中心の開発 → Cursor\n- 自律的なタスク実行 → Cline",
      "badExample": "「Copilotを入れましょう」（比較なし、チームの用途分析なし）",
      "usage": "チームのAIツール導入、開発環境標準化、生産性改善",
      "createdAt": "2026-02-18"
    },
    {
      "id": "junior-growth-roadmap-1",
      "term": "ジュニアエンジニアの成長ロードマップ",
      "type": "pattern",
      "category": "concretization-abstraction",
      "meaning": "新人〜ジュニアレベルで身につけるべきスキルを段階的に整理し、各段階の到達目標を明確にするパターン",
      "goodExample": "### Phase1: 入社〜3ヶ月（生存期）\n- [ ] 報連相を適切なタイミングで行える\n- [ ] 30分詰まったら質問できる（質問の型で）\n- [ ] 既存コードを読んで修正箇所を特定できる\n- [ ] PRを書いてレビューを受けられる\n- [ ] 日報を毎日書ける\n\n### Phase2: 3〜6ヶ月（貢献期）\n- [ ] タスクの見積もりを根拠付きで出せる\n- [ ] 小〜中規模の機能を1人で実装できる\n- [ ] テスト設計（UT/FT）を自分でできる\n- [ ] 設計レビューで質問・指摘ができる\n- [ ] 障害報告を構造化して書ける\n\n### Phase3: 6ヶ月〜1年（自走期）\n- [ ] スコープ管理と関係者調整ができる\n- [ ] 技術選定の比較・提案ができる\n- [ ] 後輩への簡単な説明・レビューができる\n- [ ] 週報で傾向分析と提案ができる\n- [ ] 設計書を書いてレビューを通せる",
      "badExample": "「3年で一人前になってね」（具体的なマイルストーンなし）",
      "usage": "新人育成計画、1on1での目標設定、自己評価、メンタリング",
      "createdAt": "2026-02-18"
    },
    {
      "id": "help-request-pattern-1",
      "term": "質問・相談の段階的テンプレート",
      "type": "pattern",
      "category": "questioning",
      "meaning": "質問の前に自分で調べ、「何を試して何がわかって何がわからないか」を構造化してから質問するパターン",
      "goodExample": "## 質問（調査済み）\n\n### やりたいこと\nユーザーテーブルにソフトデリート機能を追加したい\n\n### 調べたこと（30分）\n1. Rails の `acts_as_paranoid` gem → メンテ停止中\n2. `discard` gem → アクティブにメンテされている\n3. 自前実装（deleted_at カラム + default_scope）→ 可能だがスコープ漏れリスク\n\n### わからないこと\n- 既存プロジェクトでは `discard` と自前実装のどちらが推奨か\n- 既存のリレーション（has_many）にも影響するか\n\n### 自分の判断\n`discard` gem が安全だと思いますが、プロジェクトのポリシーを確認したいです",
      "badExample": "「ソフトデリートってどうやるんですか？」（自分で何も調べていない）",
      "usage": "技術的な質問、設計方針の相談、ツール選定の相談",
      "createdAt": "2026-02-18"
    },
    {
      "id": "pr-description-pattern-1",
      "term": "プルリクエスト記述テンプレート",
      "type": "pattern",
      "category": "explanation",
      "meaning": "PRの目的・変更内容・テスト結果・レビューポイントを構造化し、レビュアーが効率的にレビューできるようにするパターン",
      "goodExample": "## 概要\n[チケットID] ユーザー検索APIにページネーション追加\n\n## 変更理由\n全件返却で1000件超のタイムアウト対策\n\n## 変更内容\n- `GET /api/users?page=1&per_page=20` パラメータ追加\n- レスポンスに `total_count`, `total_pages` 追加\n- 後方互換あり（パラメータ省略時はデフォルト値）\n\n## 影響範囲\n- APIエンドポイント1本（既存互換）\n- フロントの呼び出し元3箇所を更新\n\n## テスト\n- 新規テスト5件追加（正常2、境界値2、異常1）\n- 既存テスト全件パス\n\n## レビューポイント\n- カーソル vs オフセットで迷い。理由はコメントに記載（L45-60）",
      "badExample": "タイトル: 「修正」\n本文: （空）",
      "usage": "日常のPR作成、コードレビュー文化の醸成",
      "createdAt": "2026-02-18"
    },
    {
      "id": "coordination-communication-pattern-1",
      "term": "関係者調整コミュニケーションパターン",
      "type": "pattern",
      "category": "reporting",
      "meaning": "変更の影響が他チーム・他メンバーに及ぶ場合の事前連絡・調整のパターン",
      "goodExample": "## 変更影響の連絡テンプレート\n\n### 1. 何が変わるか\nユーザーAPIのレスポンス形式を変更します\n- 変更点: `name` フィールドを `first_name` + `last_name` に分割\n- 変更日: 2/25（次スプリントのリリース）\n\n### 2. 誰に影響するか\n- フロントエンドチーム: ユーザー表示コンポーネント3箇所\n- モバイルチーム: ユーザープロフィールAPI呼び出し\n- QAチーム: テストデータの更新が必要\n\n### 3. 依頼事項\n- 各チームは2/22までに影響箇所を洗い出しください\n- 質問は Slack #api-changes で",
      "badExample": "API変更をリリース後に「あ、変えました」と報告。他チームのビルドが壊れる",
      "usage": "API変更、DB変更、共通ライブラリ更新、リリーススケジュール変更",
      "createdAt": "2026-02-18"
    },
    {
      "id": "prompt-engineering-1",
      "term": "プロンプトエンジニアリング",
      "type": "term",
      "category": "explanation",
      "meaning": "AIモデル（ChatGPT、Claude等）に対して、意図した回答を得るための指示文（プロンプト）を設計する技術。曖昧な指示では曖昧な回答が返る。具体的な役割・文脈・出力形式を指定する",
      "example": "【悪いプロンプト】\n「認証について教えて」\n\n【良いプロンプト】\n「あなたはNode.jsのバックエンドエンジニアです。\n以下の要件でJWT認証のミドルウェアを実装してください。\n\n【要件】\n- Express.js v4 を使用\n- access_token の検証（有効期限15分）\n- refresh_token によるトークン更新エンドポイント\n- エラー時は401/403を適切に返却\n\n【出力形式】\nTypeScriptのコードブロックで出力。各関数にJSDocコメント付き。」",
      "antiPattern": "「コード書いて」「バグ直して」だけで丸投げ。文脈なし、要件なし、出力形式の指定なし",
      "usage": "AIコーディング支援、コードレビュー依頼、技術調査、ドキュメント生成",
      "createdAt": "2026-02-18"
    },
    {
      "id": "token-context-window-1",
      "term": "トークンとコンテキストウィンドウ",
      "type": "term",
      "category": "explanation",
      "meaning": "AIモデルが処理できるテキストの単位（トークン）と、一度に扱える上限（コンテキストウィンドウ）。日本語は英語より多くのトークンを消費する。上限を超えると古い文脈が切れる",
      "example": "【トークンの目安】\n- 英語: 1単語 ≈ 1.3トークン\n- 日本語: 1文字 ≈ 1〜3トークン（英語の2〜3倍消費）\n\n【コンテキストウィンドウ】\n- GPT-4o: 128Kトークン\n- Claude 3.5: 200Kトークン\n- ローカルLLM: 4K〜32K（モデル依存）\n\n【実用的な対策】\n- 長いコードは関連部分だけ貼る\n- 「前の会話を踏まえて」ではなく要点を再度記載\n- 長い会話は要約して新しいセッションに引き継ぐ",
      "antiPattern": "プロジェクト全ファイルを貼り付けて「全部読んで」。トークン上限を超えて文脈が切れ、回答品質が劣化する",
      "usage": "AIチャット利用、API利用時のコスト管理、プロンプト設計",
      "createdAt": "2026-02-18"
    },
    {
      "id": "ai-coding-assistant-1",
      "term": "AIコーディング支援ツール",
      "type": "term",
      "category": "explanation",
      "meaning": "IDE上でAIによるコード補完・生成・説明を行うツール。GitHub Copilot、Continue、Cursor、Cline等がある。ツールの特性を理解して適切に使い分ける",
      "example": "【主要ツールと特徴】\n1. GitHub Copilot: VSCode統合、インライン補完、GPT-4ベース\n2. Continue: OSS、複数モデル対応（GPT/Claude/ローカルLLM）、カスタマイズ性高\n3. Cursor: AI特化エディタ、コードベース全体を文脈に使用\n4. Cline: VSCode拡張、自律的にファイル操作・コマンド実行\n\n【効果的な使い方】\n- ボイラープレート生成（テスト、型定義、マイグレーション）\n- 既存コードの説明・リファクタ提案\n- エラーメッセージの解析と修正提案\n- コミットメッセージ・PR本文の下書き",
      "antiPattern": "AIが生成したコードを理解せずにそのままコミットする。AIの出力を無条件に信頼してレビューしない",
      "usage": "日常の開発作業、学習、コードレビュー準備、ドキュメント作成",
      "createdAt": "2026-02-18"
    },
    {
      "id": "ai-output-verification-1",
      "term": "AI出力の検証と責任",
      "type": "term",
      "category": "logical-writing",
      "meaning": "AIが生成したコード・文章は必ず自分で検証し、正確性・セキュリティ・ライセンスの問題がないか確認すること。「AIが書いたから正しい」は通用しない。最終責任は開発者にある",
      "example": "【AI出力の検証チェックリスト】\n- [ ] コードが意図通りに動作するか（ローカルで実行確認）\n- [ ] セキュリティ上の問題がないか（SQLインジェクション、XSS等）\n- [ ] 非推奨のAPI/ライブラリを使っていないか\n- [ ] テストが書かれているか、または自分で追加したか\n- [ ] ハルシネーション（存在しないAPIの参照等）がないか\n- [ ] ライセンスの問題がないか（コピペコード）\n- [ ] 自分がこのコードを説明できるか",
      "antiPattern": "Copilotが補完したコードをそのままPR。レビューで「これ何してるの？」と聞かれて答えられない",
      "usage": "AIコーディング支援利用時、コードレビュー、品質管理",
      "createdAt": "2026-02-18"
    },
    {
      "id": "ai-effective-workflow-1",
      "term": "AI活用のワークフロー",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "AIを開発プロセスのどの段階でどう使うかを設計すること。「何でもAIに聞く」ではなく、AIが得意なタスクと人間がすべきタスクを使い分ける",
      "example": "【AIが得意なタスク】\n- ボイラープレートコード生成\n- テストケースの洗い出し\n- エラーメッセージの解析\n- 既存コードのリファクタ提案\n- ドキュメントの下書き\n\n【人間がすべきタスク】\n- 要件定義・ビジネス判断\n- アーキテクチャの最終決定\n- セキュリティレビュー\n- AI出力のレビューと修正\n- チームとのコミュニケーション\n\n【開発フローへの組み込み例】\n設計 → (AI: テストケース洗い出し) → テスト設計レビュー\n実装 → (AI: コード補完) → セルフレビュー → PRレビュー\nバグ → (AI: エラー解析) → 原因特定 → 修正",
      "antiPattern": "AIにコードを全部書かせて、自分はコピペするだけ。設計も考えずに「AIに聞けばいい」",
      "usage": "開発プロセス設計、チームのAI導入方針策定、個人の生産性向上",
      "createdAt": "2026-02-18"
    },
    {
      "id": "debug-logging-1",
      "term": "実装時のログ（デバッグログ）",
      "type": "term",
      "category": "explanation",
      "meaning": "開発・デバッグ目的で一時的に埋め込むログ。処理の流れや変数の中身を確認するために使い、本番リリース前に削除またはログレベルで制御する。`console.log` の残骸は技術負債になる",
      "example": "【実装時ログの正しい使い方】\n```javascript\n// デバッグ時: 処理の流れと変数を確認\nconsole.log('=== authenticate start ===', { email });\nconsole.log('user found:', user);\nconsole.log('bcrypt result:', isMatch);\nconsole.log('token generated:', token);\n```\n\n【リリース前に必ずやること】\n1. `console.log` を全て削除 or `logger.debug()` に置換\n2. 機密情報（パスワード、トークン）がログに出ていないか確認\n3. Lintルール `no-console` で自動検出",
      "antiPattern": "`console.log('ここに来た')` `console.log('test')` `console.log(data)` が本番コードに残っている。パスワードや個人情報がログに出力されている",
      "usage": "開発時のデバッグ、コードレビューでのログ残骸チェック",
      "createdAt": "2026-02-18"
    },
    {
      "id": "production-logging-1",
      "term": "本番ログ設計（運用ログ）",
      "type": "term",
      "category": "explanation",
      "meaning": "本番環境で障害検知・原因調査・監査に使うログ。ログレベル・構造化・出力先・保持期間を設計する。「何が起きたか」を後から追跡できることが目的",
      "example": "【本番ログの設計要素】\n1. **ログレベル**: ERROR > WARN > INFO > DEBUG\n   - ERROR: 即対応が必要（DB接続失敗、未処理例外）\n   - WARN: 注意が必要（リトライ発生、閾値超過）\n   - INFO: 正常な業務イベント（ログイン成功、注文完了）\n   - DEBUG: 詳細調査用（本番ではOFF）\n\n2. **構造化ログ（JSON形式）**:\n```json\n{\"timestamp\":\"2026-02-18T14:03:00Z\",\"level\":\"ERROR\",\"service\":\"auth-api\",\"requestId\":\"abc-123\",\"userId\":\"user-456\",\"message\":\"Authentication failed\",\"reason\":\"account_locked\",\"attempts\":5}\n```\n\n3. **出さないもの**: パスワード、トークン、個人情報、クレジットカード番号",
      "antiPattern": "本番で `console.log` だけ。ログレベルなし、構造化なし、タイムスタンプなし。障害時に「何が起きたかわからない」",
      "usage": "本番環境のログ設計、監視アラート設定、障害調査、セキュリティ監査",
      "createdAt": "2026-02-18"
    },
    {
      "id": "log-level-design-1",
      "term": "ログレベル設計",
      "type": "term",
      "category": "logical-writing",
      "meaning": "ERROR/WARN/INFO/DEBUGの各レベルに何を出力するかの基準を定義すること。レベルが適切でないと、本番でノイズが多すぎたり、障害時に情報が足りなかったりする",
      "example": "【ログレベル基準】\n| レベル | 基準 | 本番 | 例 |\n|---|---|---|---|\n| ERROR | 即対応が必要な異常 | ON | DB接続失敗、未処理例外、外部API障害 |\n| WARN | 異常だが自動復旧可能 | ON | リトライ成功、レート制限接近、非推奨API呼び出し |\n| INFO | 正常な業務イベント | ON | ユーザーログイン、注文完了、バッチ処理開始/終了 |\n| DEBUG | 開発・詳細調査用 | OFF | 変数の中身、SQL文、リクエスト/レスポンス全文 |\n\n【よくある間違い】\n- ERRORにすべき: 「DBタイムアウト」をWARNにしている → 気づかない\n- INFOにすべき: 「全リクエスト」をINFOにしている → ノイズすぎる\n- DEBUGにすべき: 「SQLクエリ全文」を本番INFOで出す → パフォーマンス劣化",
      "antiPattern": "全てのログを同じレベル（INFO）で出す。本番でDEBUGが有効のまま。ERRORとWARNの区別がない",
      "usage": "ログ設計方針策定、コードレビュー、監視アラートの閾値設定",
      "createdAt": "2026-02-18"
    },
    {
      "id": "structured-logging-1",
      "term": "構造化ログ",
      "type": "term",
      "category": "logical-writing",
      "meaning": "ログをJSON等の機械可読な形式で出力し、ログ収集ツール（Datadog, CloudWatch, ELK等）で検索・集計・アラートを可能にすること。人間が読むだけでなく、ツールが解析できる形にする",
      "example": "【非構造化ログ（人間用）】\n`[2026-02-18 14:03:00] ERROR: ユーザー user-456 の認証に失敗しました（ロック中）`\n→ grep で検索するしかない。集計困難\n\n【構造化ログ（機械可読）】\n```json\n{\n  \"timestamp\": \"2026-02-18T14:03:00Z\",\n  \"level\": \"ERROR\",\n  \"service\": \"auth-api\",\n  \"requestId\": \"req-abc-123\",\n  \"userId\": \"user-456\",\n  \"action\": \"authenticate\",\n  \"result\": \"failure\",\n  \"reason\": \"account_locked\",\n  \"metadata\": { \"attempts\": 5, \"lockUntil\": \"14:33:00Z\" }\n}\n```\n→ `reason=account_locked` でフィルタ、時間帯ごとの集計、アラート設定が可能",
      "antiPattern": "ログが自由記述のテキスト。障害時に `grep` で頑張って検索。集計やダッシュボードが作れない",
      "usage": "ログ基盤設計、監視ダッシュボード構築、障害調査の効率化",
      "createdAt": "2026-02-18"
    },
    {
      "id": "log-security-1",
      "term": "ログのセキュリティ",
      "type": "term",
      "category": "questioning",
      "meaning": "ログに機密情報を出力しないこと。パスワード・トークン・個人情報・クレジットカード番号等がログに残ると、ログ流出時に重大なセキュリティインシデントになる",
      "example": "【出してはいけないもの】\n- パスワード（平文・ハッシュ含む）\n- アクセストークン / リフレッシュトークン\n- 個人情報（住所、電話番号、メール※場合による）\n- クレジットカード番号\n- APIキー / シークレット\n\n【マスキングの例】\n```javascript\n// NG\nlogger.info('Login attempt', { email, password });\n// OK\nlogger.info('Login attempt', { email, password: '***' });\n// OK（そもそもpasswordをログに渡さない）\nlogger.info('Login attempt', { email });\n```",
      "antiPattern": "デバッグ中に `console.log(req.body)` でリクエスト全体を出力 → パスワードやトークンがログに残る",
      "usage": "コードレビュー、セキュリティ監査、ログ設計ガイドライン策定",
      "createdAt": "2026-02-18"
    },
    {
      "id": "log-comparison-pattern-1",
      "term": "実装時ログ vs 本番ログ比較パターン",
      "type": "pattern",
      "category": "explanation",
      "meaning": "実装（デバッグ）段階のログと本番運用のログの違いを対比し、リリース前に適切なログ設計に切り替えるためのパターン",
      "goodExample": "## 実装時ログ vs 本番ログ 比較表\n\n| 観点 | 実装時（デバッグ） | 本番（運用） |\n|---|---|---|\n| **目的** | 動作確認・バグ特定 | 障害検知・監視・監査 |\n| **出力先** | コンソール（stdout） | ファイル/ログ集約基盤（Datadog等） |\n| **ログレベル** | DEBUG/TRACE含む全レベル | INFO以上（DEBUGは原則OFF） |\n| **出力形式** | 自由テキスト（人間向け） | 構造化JSON（機械処理向け） |\n| **寿命** | 一時的（実装完了で削除） | 永続的（保持期間はポリシーに従う） |\n| **機密情報** | 開発環境なら許容（本番データ禁止） | 絶対NG（マスキング必須） |\n| **パフォーマンス** | 気にしない | 高負荷時の影響を考慮 |\n\n## リリース前チェック\n- [ ] `console.log` / `console.debug` が残っていないか\n- [ ] ログレベルが適切か（DEBUGが本番で有効になっていないか）\n- [ ] 機密情報がログに含まれていないか\n- [ ] 構造化ログ形式になっているか",
      "badExample": "実装時の `console.log('ここ通った')` `console.log(data)` をそのまま本番にリリース。\n→ 不要なログが大量に出力されディスクを圧迫\n→ ユーザーの個人情報がログに平文で記録される\n→ 障害発生時に必要な情報がノイズに埋もれて見つからない",
      "usage": "コードレビュー、リリース前チェックリスト、ログ設計ガイドライン",
      "createdAt": "2026-02-18"
    },
    {
      "id": "log-design-checklist-pattern-1",
      "term": "ログ設計チェックリスト",
      "type": "pattern",
      "category": "logical-writing",
      "meaning": "本番リリース前にログ出力を点検するためのチェックリスト。開発用ログの残存・レベル設定・セキュリティ・構造化を網羅的に確認する",
      "goodExample": "## ログ設計チェックリスト\n\n### 1. デバッグログの除去\n- [ ] `console.log` / `console.debug` / `print` 文がコードに残っていないか\n- [ ] `// TODO: 後で消す` 付きのログ出力が残っていないか\n- [ ] デバッガ用の一時変数・ダンプが残っていないか\n\n### 2. ログレベルの適切さ\n- [ ] ERROR: システムが正常に動作できない事象のみに使用\n- [ ] WARN: 想定外だが処理は継続できる事象に使用\n- [ ] INFO: 正常な業務イベント（開始/完了/重要な状態変化）に使用\n- [ ] DEBUG: 本番では原則OFF、開発時のみ有効\n\n### 3. セキュリティ\n- [ ] パスワード・トークン・APIキーがログに含まれていないか\n- [ ] 個人情報（PII）がマスキングされているか\n- [ ] リクエストボディの全出力（`req.body`）をしていないか\n\n### 4. 運用観点\n- [ ] 構造化ログ（JSON形式）になっているか\n- [ ] requestId / traceId でリクエスト追跡可能か\n- [ ] タイムスタンプがISO 8601形式か\n- [ ] ログローテーション設定があるか",
      "badExample": "チェックリストなし。各開発者が自由にログを書き、レビューでもログの品質は確認しない\n→ 本番ログが `console.log('debug:', data)` だらけ\n→ 障害時に有用な情報がない",
      "usage": "PR レビュー、リリース前確認、ログ設計方針の策定",
      "createdAt": "2026-02-18"
    },
    {
      "id": "log-level-usage-pattern-1",
      "term": "ログレベル運用パターン",
      "type": "pattern",
      "category": "reporting",
      "meaning": "各ログレベルの使い分けを具体的なコード例で示し、チーム全体で統一したログ運用を実現するパターン",
      "goodExample": "## ログレベル運用ガイド\n\n### ERROR（即時対応が必要）\n```javascript\nlogger.error('Payment processing failed', {\n  orderId: order.id,\n  errorCode: err.code,\n  message: err.message\n});\n```\n→ アラート通知 → オンコール対応\n\n### WARN（要注意だが処理継続）\n```javascript\nlogger.warn('API response slow', {\n  endpoint: '/api/users',\n  responseTime: 2500,\n  threshold: 2000\n});\n```\n→ ダッシュボード監視 → 傾向分析\n\n### INFO（正常な業務イベント）\n```javascript\nlogger.info('User login successful', {\n  userId: user.id,\n  method: 'oauth',\n  timestamp: new Date().toISOString()\n});\n```\n→ 監査ログ → 利用統計\n\n### DEBUG（開発時のみ）\n```javascript\nlogger.debug('Cache lookup', {\n  key: cacheKey,\n  hit: !!cachedValue\n});\n```\n→ 本番ではOFF → 必要時のみ一時的にON",
      "badExample": "全てのログを `logger.info()` で出力。重要度が区別できず、障害時に ERROR ログだけでフィルタリングできない",
      "usage": "チームのログ規約策定、コードレビュー、障害対応の効率化",
      "createdAt": "2026-02-18"
    },
    {
      "id": "reporting-horenso-1",
      "term": "報連相（ホウレンソウ）の型",
      "type": "term",
      "category": "reporting",
      "meaning": "報告・連絡・相談を適切なタイミングと粒度で行うこと。新人が最も早く身につけるべきスキル。「聞かれる前に報告」「困ったら早めに相談」が鉄則",
      "example": "【報告】「タスクAが完了しました。次にタスクBに着手します」\n【連絡】「明日午後、病院のため15時に退勤します」\n【相談】「タスクCの実装方針で2案あり迷っています。A案は○○、B案は△△。工数的にA案がよいと思いますがいかがでしょうか」",
      "antiPattern": "報告: 聞かれるまで黙っている\n連絡: 当日朝に急に休む連絡\n相談: 3日間一人で悩んで進捗ゼロ",
      "usage": "日常のチーム内コミュニケーション、1on1、デイリースタンドアップ",
      "createdAt": "2026-02-18"
    },
    {
      "id": "asking-for-help-1",
      "term": "助けを求める技術",
      "type": "term",
      "category": "questioning",
      "meaning": "自分で調べた上で、何がわからないかを明確にして助けを求めること。「全くわかりません」ではなく「ここまで理解したがここで詰まっている」と伝える",
      "example": "【やったこと】公式ドキュメントを読み、サンプルコードを動かしました\n【わかったこと】基本的なCRUDの書き方は理解しました\n【わからないこと】トランザクション処理でネストした場合のロールバック挙動\n【試したこと】savepoint を使ってみたがエラーになる（エラーメッセージ添付）\n【質問】savepointの使い方が間違っていますか？それとも別のアプローチがありますか？",
      "antiPattern": "「動きません。助けてください。」（何を試したか、どこで詰まっているか不明）",
      "usage": "技術的な質問、コードレビューでの疑問、設計相談",
      "createdAt": "2026-02-18"
    },
    {
      "id": "estimation-skill-1",
      "term": "見積もりの伝え方",
      "type": "term",
      "category": "reporting",
      "meaning": "作業工数の見積もりを根拠付きで伝えること。「だいたい2日」ではなく、作業を分解して積み上げた根拠を示す",
      "example": "【タスク】ユーザー検索APIの実装\n【見積もり内訳】\n1. DB設計・マイグレーション: 1h\n2. API実装（検索ロジック+ページネーション）: 3h\n3. テスト作成: 2h\n4. コードレビュー対応: 1h\n【合計】7h（バッファ20%込みで約1日）\n【前提条件】Elasticsearch未使用、SQLのLIKE検索で実装\n【リスク】要件変更で全文検索が必要になった場合は+2日",
      "antiPattern": "「たぶん2〜3日くらいです」（根拠なし、内訳なし、前提条件なし）",
      "usage": "スプリント計画、タスク見積もり、上長への工数報告",
      "createdAt": "2026-02-18"
    },
    {
      "id": "scope-management-1",
      "term": "スコープ管理と合意形成",
      "type": "term",
      "category": "explanation",
      "meaning": "「やること」と「やらないこと」を明確にし、関係者と合意すること。スコープが曖昧だと際限なく仕事が増え、納期も品質も崩壊する",
      "example": "【やること（In Scope）】\n- ユーザー検索API（名前・メール部分一致）\n- ページネーション（20件/ページ）\n- 検索結果のCSVエクスポート\n\n【やらないこと（Out of Scope）】\n- 全文検索（Elasticsearch導入は次フェーズ）\n- リアルタイム検索サジェスト\n- 検索履歴の保存\n\n【判断理由】MVP として最小限の機能に絞り、2週間でリリース",
      "antiPattern": "「検索機能を作る」だけ合意し、開発中に「ソート」「フィルタ」「サジェスト」が次々追加されて工期が2倍に",
      "usage": "要件定義、スプリント計画、見積もり前の合意形成",
      "createdAt": "2026-02-18"
    },
    {
      "id": "stakeholder-coordination-1",
      "term": "ステークホルダー調整",
      "type": "term",
      "category": "reporting",
      "meaning": "プロジェクトに関わる複数の関係者（PO、デザイナー、QA、インフラ等）の間で情報を共有し、認識のずれを防ぐこと。ジュニアレベルでは「自分のタスクに関わる人に適切に連絡する」がまず重要",
      "example": "【調整が必要な場面と対応】\n1. API仕様変更 → フロントエンド担当に事前連絡\n2. DBスキーマ変更 → DBA・他チームに影響確認\n3. 画面デザイン変更 → デザイナーに確認後に実装\n4. テスト環境利用 → QAチームとスケジュール調整\n5. リリース日変更 → PO・営業に早期エスカレーション",
      "antiPattern": "API仕様を黙って変更し、フロントエンドが動かなくなる。DBスキーマを変えて他チームのバッチが壊れる",
      "usage": "日常の開発作業、設計変更時、リリース調整、障害対応",
      "createdAt": "2026-02-18"
    },
    {
      "id": "meeting-facilitation-1",
      "term": "会議参加と発言の型",
      "type": "term",
      "category": "explanation",
      "meaning": "会議で効果的に情報を受け取り、適切に発言するスキル。新人は「黙って座っている」か「的外れな発言をする」のどちらかになりがち",
      "example": "【会議前の準備】\n- アジェンダを確認し、自分の担当部分を把握\n- 質問・共有事項を事前に書き出す\n\n【発言の型】\n- 状況報告: 「○○の進捗ですが、予定通り完了しています」\n- 質問: 「確認ですが、この仕様は△△という理解で合っていますか？」\n- 提案: 「1つ提案ですが、□□の方法もあると思います。理由は〜」\n\n【会議後】\n- 決定事項と自分のアクションアイテムをメモ\n- 不明点があればその日中に確認",
      "antiPattern": "会議中は黙って聞いているだけ。終わった後に「実はよくわかっていなかった」と言い出す",
      "usage": "デイリースタンドアップ、設計レビュー、スプリント計画、振り返り",
      "createdAt": "2026-02-18"
    },
    {
      "id": "code-reading-skill-1",
      "term": "コードリーディング",
      "type": "term",
      "category": "concretization-abstraction",
      "meaning": "既存コードベースを効率的に読み解き、全体構造と変更箇所を特定するスキル。新人の最初のタスクは「新しいコードを書く」より「既存コードを理解する」ことが多い",
      "example": "【コードリーディングの手順】\n1. README / ドキュメントで全体像を把握\n2. ディレクトリ構成からモジュール分割を理解\n3. エントリポイント（main, app.ts等）から処理の流れを追う\n4. 変更対象の機能に関連するファイルを特定\n5. テストコードを読んで期待される動作を理解\n6. git log / git blame で変更履歴と意図を確認\n\n【メモの取り方】\n「○○クラスは△△を担当」「□□の処理は■■ファイルのL120-150」のようにメモ",
      "antiPattern": "コードを読まずにいきなり修正を始める。全ファイルを1行ずつ読もうとして時間を浪費する",
      "usage": "新規プロジェクト参画時、バグ調査、コードレビュー、機能追加の事前調査",
      "createdAt": "2026-02-18"
    },
    {
      "id": "time-management-1",
      "term": "タイムボックスと優先度管理",
      "type": "term",
      "category": "logical-writing",
      "meaning": "作業に時間の上限（タイムボックス）を設け、優先度に基づいて取捨選択すること。完璧を目指すより、制限時間内にベストを出す",
      "example": "【タイムボックスの活用】\n- 調査: 「この技術調査は2時間で区切る。2時間で結論が出なければ相談する」\n- バグ調査: 「30分自分で調べてわからなければ先輩に聞く」\n- コードレビュー: 「1PR あたり30分を目安に」\n\n【優先度判断】\n1. 緊急＋重要: 本番障害 → 即対応\n2. 重要だが緊急でない: 技術負債改善 → 計画的に\n3. 緊急だが重要でない: 軽微なバグ報告 → 次スプリント\n4. どちらでもない: 後回し or やらない",
      "antiPattern": "1つの調査に丸一日かけてしまい、本来やるべきタスクが手つかず。優先度を考えず来た順に処理する",
      "usage": "日常のタスク管理、スプリント中の作業判断、割り込みタスクへの対応",
      "createdAt": "2026-02-18"
    },
    {
      "id": "pr-writing-1",
      "term": "プルリクエストの書き方",
      "type": "term",
      "category": "explanation",
      "meaning": "変更の目的・内容・テスト結果をレビュアーに正確に伝えるPR本文の書き方。レビュアーの時間を尊重し、効率的にレビューできる情報を提供する",
      "example": "## 概要\nユーザー検索APIにページネーションを追加\n\n## 変更理由\n現状は全件返却で1000件超えるとタイムアウト。20件/ページで返却に変更。\n\n## 変更内容\n- `GET /api/users?page=1&per_page=20` のクエリパラメータ追加\n- レスポンスに `total_count`, `total_pages` を追加\n- 既存の `GET /api/users` は後方互換（デフォルト page=1, per_page=20）\n\n## テスト\n- 新規テスト5件追加（正常系2、境界値2、異常系1）\n- 既存テスト全件パス\n\n## レビューポイント\n- ページネーションのカーソル方式 vs オフセット方式で迷いました（L45-60）",
      "antiPattern": "PR本文が空。タイトルが「fix」だけ。変更理由もテスト結果もない",
      "usage": "コードレビュー依頼、チーム開発でのナレッジ共有",
      "createdAt": "2026-02-18"
    },
    {
      "id": "feedback-receiving-1",
      "term": "フィードバックの受け取り方",
      "type": "term",
      "category": "questioning",
      "meaning": "レビューや指摘を建設的に受け止め、改善に活かすスキル。反射的に反論したり落ち込んだりせず、「何を学べるか」に集中する",
      "example": "【レビューコメントへの対応】\n1. まず内容を理解する（感情的に反応しない）\n2. 指摘が正しい → 修正して「ご指摘ありがとうございます。修正しました」\n3. 意図が不明 → 「この指摘は○○という理解で合っていますか？」\n4. 別の意見がある → 「こちらの方法にした理由は○○です。△△の観点ではいかがでしょうか？」\n\n【1on1でのフィードバック】\n- メモを取る\n- 具体的な改善アクションを確認する\n- 「次はいつまでに何をすればよいか」を明確にする",
      "antiPattern": "指摘に対して「でも」「だって」で反論する。全ての指摘を個人攻撃と受け取る。フィードバックを聞いたが何も変えない",
      "usage": "コードレビュー、1on1、評価面談、振り返り",
      "createdAt": "2026-02-18"
    },
    {
      "id": "documentation-habit-1",
      "term": "ドキュメント習慣",
      "type": "term",
      "category": "logical-writing",
      "meaning": "自分の作業・学び・決定事項を文書として残す習慣。口頭の情報は消えるが、文書は残り、チームの資産になる",
      "example": "【日常で残すべきドキュメント】\n1. 作業ログ: 「何をやって何がわかったか」の日次メモ\n2. 手順書: 環境構築・デプロイなど繰り返す作業の手順\n3. 決定記録: 「なぜこの設計にしたか」のADR\n4. トラブルシューティング: 「このエラーはこう解決した」\n5. 引き継ぎメモ: 自分しか知らないことを文書化\n\n【書く場所の使い分け】\n- 即時共有: Slack（フロー情報）\n- 永続的なナレッジ: Wiki/Notion（ストック情報）\n- コードに近い情報: README、コメント、ADR",
      "antiPattern": "全てを口頭でやりとりし、文書が一切残らない。半年後に「なぜこの実装にしたんだっけ」がわからなくなる",
      "usage": "日常業務、引き継ぎ、ナレッジ共有、振り返り",
      "createdAt": "2026-02-18"
    }
  ]
}
